David Chuong - 100860614
Oscar Gao -  100866004

This is a write up on our course project that explains the different design patterns we have learned in class and how we have applied them into our project.

Singleton
Singletons will be the main objects that all other objects will send information to. What we’ve implemented to showcase this are a UIManager and a WorldSpaceMouse converter as these are key objects that our project needs and are accessed very frequently. UIManager is self explanatory as it lets us navigate through the menus properly and lets us switch between scenes or close the game. It also gives us access to settings, allowing us to change our keybinds for the command pattern. WorldSpaceMouse turns our mouse cursor into a raycast which lights up tiles if that raycast hits them successfully. This will highlight the tile that the cursor is hovering over and will display that a tower is placeable in that location. Left-clicking will place down a tower on the tile if it can do so. Since knowing where a tower can be placed is a vital component to our game, we decided that turning it into a singleton was fitting as it made sure it was always present, thus not breaking our game with these objects not being there. 

Observer
Observers will be used whenever there's a change in an object's state and things need to be updated accordingly. We’ve implemented observers for the TowerManager and the ResourceManager. The TowerManager serves as an announcer and sends notifications to the ResourceManager which is the listener. The ResourceManager listens for tower related events such as when a tower is sold or if it is upgraded. These events notify the ResourceManager to update the amount of in-game currency to reflect the amount added from selling towers and the amount subtracted from upgrading towers. The ResourceManager itself is also an announcer. It announces events to ResourceUI which displays the amount of currency to a small UI panel so that the player knows how much currency they have to put towards upgrading their towers. 

Command
Command is used whenever we need to create an object that contains a large set of commands, allowing us to use it anywhere without knowing where it came from while still executing it. We’ve successfully implemented Tower Commands/Actions and Saving Custom Keybinds. Tower Commands were one of the implementations we showed for assignment 1. We put certain commands into buttons connected to the tower, thus determining what we do with it. We have 3 buttons associated with towers other than buying them. That being upgrading, selling and storing. Upgrading is self explanatory, when we click on the button the tower will upgrade by having a different model design and dealing more dmg, having more range, hp or whatever else we deem fit for that tower’s upgrades. Next is selling where we delete the turret and give money to the player at a reduced price so they can upgrade other towers or buy a new one to fit the situation of the map. Our other command design pattern implementation is letting the players have custom keybinds. When you go into the settings in the main menu you click on whatever keybind you wish to change and it updates to the new keybind. It also saves these custom keybinds in a .json file so whenever you relaunch the game the scripts will load and read the .json file and update the keybinds accordingly. 

Factory
We’ve implemented the factory pattern for the creation of different types of towers, and enemies. The TowerFactory and EnemyFactory enabled us to create many different variations of enemies and towers by simply changing the type of factory used to create the objects. This is a tower defense game so it was helpful to be able to easily interchange factories to create new objects when needed. For the towers, implementation consisted of several different factories. TurretTowerFactory, LaserTowerFactory, and AOETowerFactory. Using the TowerOptionsUI, we created 3 different buttons for changing the currently selected tower’s type. Each button would execute a different function using their respective tower factory to create and replace the currently selected tower.  For enemy creation, there existed a BasicEnemyFactory, BruteEnemyFactory, and BossEnemyFactory. Using the EnemySpawner script, we instantiated a number of inactive enemies at the start of the game using the enemy factories. We created a function that takes parameters for an enemy factory and an integer. The function then instantiates the specified number of enemies with an enemy type based on the enemy factory used.

Optimizations
Optimization patterns are used when we want to optimize our game so it takes up less resources, thus letting it run more efficiently and being less prone to crashing or an object throwing an error. The two optimization design patterns we’ve implemented are Object Pooling and Flyweight. Object Pooling is very simple but limits the max number of whatever objects we want to have present at any given time. It works by spawning a certain number of whatever we want to be spawned when we load the game or scene and objects take things out from that pool whenever they need to use it. Once they are done with using that object, it will be returned to the pool for future use again.  In our case we used it for the ranged tower’s projectile as there can be multiple of them shooting simultaneously at any given time. Thus making it the perfect place to use Object Pooling and limit how many projectiles we want on screen at any given time. Flyweight works by storing any unchanging and/or common data between objects and calling on what we store whenever we create an object that originally had that data, thus reducing how many resources they take up. We did this by creating ScriptableObjects for TowerData and EnemyData. These two data containers hold variables that are common among specific types of towers and enemies. 

Contributions
Oscar Gao - 70%
David Chuong - 30%
